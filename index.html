<!-- index.html â€” open in any browser -->
<!DOCTYPE html>
<html>
<head>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.15.0/dist/tf-backend-webgl.min.js"></script>
  <script>
    // Force WebGL backend configuration before any TF operations
    tf.env().set('WEBGL_VERSION', 2);  // Force WebGL 2
    tf.env().set('WEBGL_CPU_FORWARD', false);  // Prevent CPU fallback
    tf.env().set('WEBGL_PACK', true);
    tf.env().set('WEBGL_FORCE_F16_TEXTURES', true);
    tf.env().set('WEBGL_FLUSH_THRESHOLD', 1);  // Aggressive GPU memory cleanup
    tf.env().set('WEBGL_PACK_BINARY_OPERATIONS', true);
    tf.env().set('WEBGL_USE_SHAPES_UNIFORMS', true);
    tf.env().set('CPU_HANDOFF_SIZE_THRESHOLD', 1024); // Prevent large tensor CPU handoff

    // Initialize TensorFlow.js to use WebGL
    async function initializeTensorFlowGPU() {
      try {
        await tf.setBackend('webgl');
        await tf.ready();
        
        // Get WebGL context and check capabilities
        const gl = await tf.backend().getGPGPUContext().gl;
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        const gpuInfo = debugInfo ? {
          vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
          renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
        } : {
          vendor: gl.getParameter(gl.VENDOR),
          renderer: gl.getParameter(gl.RENDERER)
        };

        // Profile GPU capabilities
        const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        const maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        
        console.log('GPU Capabilities:', {
          ...gpuInfo,
          maxTextureSize,
          maxTextureUnits,
          webglVersion: gl.getParameter(gl.VERSION),
          backend: tf.getBackend(),
          isWebGL2: gl instanceof WebGL2RenderingContext
        });

        // Enable profiling
        tf.enableDebugMode();
        tf.profile(true);

        // Test GPU compute capability
        const testTensor = tf.tidy(() => {
          const x = tf.randomNormal([1000, 1000]);
          const start = performance.now();
          const result = tf.matMul(x, x.transpose());
          const end = performance.now();
          console.log('GPU Compute Test:', {
            time: (end - start).toFixed(2) + 'ms',
            shape: result.shape,
            backend: result.backend
          });
          return result;
        });
        testTensor.dispose();

        // Update UI with GPU status
        document.getElementById('modelInfo').innerHTML += `
          <div class="gpu-status success">
            <div>GPU Acceleration: Active</div>
            <div>Device: ${gpuInfo.renderer}</div>
            <div>WebGL: ${gl instanceof WebGL2RenderingContext ? '2.0' : '1.0'}</div>
            <div>Memory: ${formatBytes(tf.memory().numBytes)} allocated</div>
          </div>
        `;

        // Monitor memory usage
        setInterval(() => {
          const memInfo = tf.memory();
          console.log('TF Memory:', {
            numTensors: memInfo.numTensors,
            numDataBuffers: memInfo.numDataBuffers,
            bytesInGPU: formatBytes(memInfo.numBytes)
          });
        }, 5000);

      } catch (error) {
        console.error('GPU Initialization Error:', error);
        document.getElementById('modelInfo').innerHTML += `
          <div class="gpu-status error">
            <div>GPU Acceleration Failed</div>
            <div>Error: ${error.message}</div>
            <div>Using CPU Fallback</div>
          </div>
        `;
      }
    }

    function formatBytes(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Initialize before page load
    document.addEventListener('DOMContentLoaded', async () => {
      await initializeTensorFlowGPU();
    });
  </script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    .data-display {
      margin: 20px 0;
      padding: 15px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background-color: #f9f9f9;
    }
    .button-group {
      margin: 10px 0;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      font-weight: bold;
    }
    .record-btn {
      background-color: #4CAF50;
      color: white;
    }
    .stop-btn {
      background-color: #f44336;
      color: white;
    }
    .train-btn {
      background-color: #2196F3;
      color: white;
    }
    .identify-btn {
      background-color: #9c27b0;
      color: white;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .user-section {
      margin-bottom: 20px;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    input[type="text"] {
      padding: 8px;
      margin: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 200px;
    }
    .status {
      margin: 10px 0;
      padding: 10px;
      border-radius: 4px;
    }
    .recording {
      background-color: #ffebee;
    }
    .prediction-result {
      font-weight: bold;
      font-size: 1.2em;
      margin: 10px 0;
    }
    .confidence-bar {
      width: 100%;
      height: 20px;
      background-color: #f0f0f0;
      border-radius: 10px;
      margin: 10px 0;
      overflow: hidden;
    }
    .confidence-fill {
      height: 100%;
      background-color: #4CAF50;
      transition: width 0.3s ease;
    }
    .prediction-details {
      margin: 10px 0;
      padding: 10px;
      background-color: #f8f9fa;
      border-radius: 4px;
    }
    .prediction-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    .confidence-value {
      color: #2196F3;
      font-weight: bold;
    }
    .current-value {
      color: #4CAF50;
      font-weight: bold;
    }
    .confidence-container {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .confidence-bar.current {
      height: 8px;
    }
    .confidence-bar.current .confidence-fill {
      background-color: #4CAF50;
    }
    .gpu-status {
      margin: 10px 0;
      padding: 10px;
      border-radius: 4px;
      font-weight: bold;
    }
    
    .gpu-status.success {
      background-color: #e8f5e9;
      color: #2e7d32;
      border: 1px solid #a5d6a7;
    }
    
    .gpu-status.warning {
      background-color: #fff3e0;
      color: #ef6c00;
      border: 1px solid #ffcc80;
    }
    
    .gpu-status.error {
      background-color: #ffebee;
      color: #c62828;
      border: 1px solid #ef9a9a;
    }

    .identification-active {
      animation: pulse 2s infinite;
      background-color: #e8f5e9;
      border: 2px solid #4CAF50;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-active {
      background-color: #4CAF50;
      animation: blink 1s infinite;
    }

    .status-inactive {
      background-color: #757575;
    }

    @keyframes blink {
      0% { opacity: 1; }
      50% { opacity: 0.4; }
      100% { opacity: 1; }
    }
  </style>
</head>
<body>
<h2>Mouse Movement User Identification System</h2>

<div class="user-section">
  <h3>Step 1: Record User Data</h3>
  <div>
    <input type="text" id="username" placeholder="Enter username">
    <div class="button-group">
      <button id="startRecording" class="record-btn">Start Recording</button>
      <button id="stopRecording" class="stop-btn" disabled>Stop Recording</button>
    </div>
  </div>
  <div id="recordingStatus" class="status"></div>
</div>

<div class="user-section">
  <h3>Step 2: Train Model</h3>
  <div class="button-group">
    <button id="trainModel" class="train-btn" disabled>Train Neural Network Model</button>
  </div>
  <div id="trainingStatus" class="status"></div>
</div>

<div class="user-section">
  <h3>Step 3: Identify User</h3>
  <div class="button-group">
    <button id="startIdentification" class="identify-btn" disabled>Start Identification</button>
    <button id="stopIdentification" class="stop-btn" disabled>Stop Identification</button>
  </div>
  <div id="identificationStatus" class="status"></div>
  <div id="identificationResult" class="status"></div>
</div>

<div id="currentData" class="data-display">
  <h4>Current Mouse Data:</h4>
  <div id="feed">Move the mouse to collect data...</div>
</div>

<div id="modelInfo" class="data-display">
  <h4>Model Information:</h4>
  <div id="usersList"></div>
</div>

<script>
const N = 20; // Window size for mouse movements
let points = [];
let isCollecting = false;
let currentMode = null;
let usersData = {};
let model = null;
let predictionHistory = [];
const PREDICTION_WINDOW = 220;

// Ensure GPU is initialized before any TF operations
let isGPUInitialized = false;

let isIdentifying = false;

// Helper function to get movement features
function getFeatures(movements) {
  const speeds = movements.map(p => p.v);
  const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
  const maxSpeed = Math.max(...speeds);
  const xMovements = movements.map(p => p.x);
  const yMovements = movements.map(p => p.y);
  const avgX = xMovements.reduce((a, b) => a + b, 0) / xMovements.length;
  const avgY = yMovements.reduce((a, b) => a + b, 0) / yMovements.length;
  
  return [avgSpeed, maxSpeed, avgX, avgY];
}

// Mouse movement handler
function handleMouseMove(e) {
  if (!isCollecting) return;

  if (points.length) {
    const p = points.at(-1);
    const dt = e.timeStamp - p.t || 1;
    const speed = Math.hypot(e.clientX - p.x, e.clientY - p.y) / dt;
    points.push({ v: speed, t: e.timeStamp, x: e.clientX, y: e.clientY });
  } else {
    points.push({ v: 0, t: e.timeStamp, x: e.clientX, y: e.clientY });
  }

  if (points.length > N) {
    points.shift();
    updateFeed();
    
    if (currentMode === 'identification' && points.length === N) {
      identifyUser();
    }
  }
}

// Update data display
function updateFeed() {
  const speeds = points.slice(-N).map(p => p.v.toFixed(2));
  feed.textContent = `Recent mouse speeds: [${speeds.join(', ')}]`;
}

// Train model
async function trainModel() {
  if (!isGPUInitialized) {
    await initializeTensorFlowGPU();
    isGPUInitialized = true;
  }

  // Profile training performance
  const trainingStart = performance.now();
  
  const usernames = Object.keys(usersData);
  console.log('Training model for users:', usernames);
  
  if (usernames.length < 2) {
    alert('Need at least 2 users to train the model');
    return;
  }

  // Prepare training data
  let X = [];
  let y = [];
  
  usernames.forEach((username, index) => {
    const userData = usersData[username];
    console.log(`Processing data for ${username}, ${userData.length} points`);
    
    if (userData.length < N) {
      throw new Error(`Not enough data points for user ${username}`);
    }
    
    for (let i = 0; i <= userData.length - N; i++) {
      const window = userData.slice(i, i + N);
      X.push(getFeatures(window));
      const output = new Array(usernames.length).fill(0);
      output[index] = 1;
      y.push(output);
    }
  });

  // Batch process the data to GPU
  const BATCH_SIZE = 32;
  const xs = [];
  const ys = [];
  
  for (let i = 0; i < X.length; i += BATCH_SIZE) {
    const batchX = X.slice(i, i + BATCH_SIZE);
    const batchY = y.slice(i, i + BATCH_SIZE);
    
    const batchXTensor = tf.tidy(() => tf.tensor2d(batchX).toFloat());
    const batchYTensor = tf.tidy(() => tf.tensor2d(batchY).toFloat());
    
    xs.push(batchXTensor);
    ys.push(batchYTensor);
  }

  try {
    // Use tf.tidy for the entire training process
    await tf.tidy(async () => {
      // Create model with GPU optimization flags
      model = tf.sequential({
        layers: [
          tf.layers.dense({
            inputShape: [4],
            units: 64,
            activation: 'relu',
            kernelRegularizer: tf.regularizers.l2({ l2: 0.02 }),
            useBias: true,
            kernelInitializer: 'glorotNormal',
            biasInitializer: 'zeros'
          }),
          tf.layers.batchNormalization(),
          tf.layers.dropout({ rate: 0.3 }),
          
          // Layer 2
          tf.layers.dense({
            units: 48,
            activation: 'relu',
            kernelRegularizer: tf.regularizers.l2({ l2: 0.02 })
          }),
          tf.layers.batchNormalization(),
          tf.layers.dropout({ rate: 0.3 }),
          
          // Layer 3
          tf.layers.dense({
            units: 32,
            activation: 'relu',
            kernelRegularizer: tf.regularizers.l2({ l2: 0.02 })
          }),
          tf.layers.batchNormalization(),
          tf.layers.dropout({ rate: 0.35 }),
          
          // Layer 4
          tf.layers.dense({
            units: 24,
            activation: 'relu',
            kernelRegularizer: tf.regularizers.l2({ l2: 0.02 })
          }),
          tf.layers.batchNormalization(),
          tf.layers.dropout({ rate: 0.35 }),
          
          // Layer 5
          tf.layers.dense({
            units: 16,
            activation: 'relu',
            kernelRegularizer: tf.regularizers.l2({ l2: 0.02 })
          }),
          tf.layers.batchNormalization(),
          tf.layers.dropout({ rate: 0.4 }),
          
          // Layer 6: Output layer
          tf.layers.dense({
            units: usernames.length,
            activation: 'softmax',
            kernelRegularizer: tf.regularizers.l2({ l2: 0.02 })
          })
        ]
      });

      // Compile with GPU optimizations
      const optimizer = tf.train.adam(0.0001);
      optimizer.minimize = () => optimizer.minimize(() => {
        const pred = model.predict(tf.concat(xs));
        return tf.losses.softmaxCrossEntropy(tf.concat(ys), pred);
      }, true);

      model.compile({
        optimizer: optimizer,
        loss: 'categoricalCrossentropy',
        metrics: ['accuracy']
      });

      const result = await model.fit(tf.concat(xs), tf.concat(ys), {
        epochs: 500,
        batchSize: BATCH_SIZE,
        validationSplit: 0.2,
        shuffle: true,
        callbacks: {
          onEpochEnd: (epoch, logs) => {
            if (epoch % 100 === 0) {
              const memInfo = tf.memory();
              document.getElementById('trainingStatus').innerHTML = `
                Training... Epoch ${epoch + 1}/500<br>
                Loss: ${logs.loss.toFixed(4)}<br>
                Training Accuracy: ${(logs.acc * 100).toFixed(2)}%<br>
                Validation Loss: ${logs.val_loss.toFixed(4)}<br>
                Validation Accuracy: ${(logs.val_acc * 100).toFixed(2)}%<br>
                GPU Memory: ${formatBytes(memInfo.numBytes)}
              `;
            }
          }
        }
      });

      const trainingEnd = performance.now();
      console.log('Training Performance:', {
        time: ((trainingEnd - trainingStart) / 1000).toFixed(2) + 's',
        backend: tf.getBackend(),
        memoryUsed: formatBytes(tf.memory().numBytes)
      });

      document.getElementById('trainingStatus').innerHTML = `
        Training Complete!<br>
        Time: ${((trainingEnd - trainingStart) / 1000).toFixed(2)}s<br>
        Final Training Accuracy: ${(result.history.acc[result.history.acc.length - 1] * 100).toFixed(2)}%<br>
        Final Validation Accuracy: ${(result.history.val_acc[result.history.val_acc.length - 1] * 100).toFixed(2)}%<br>
        GPU Memory: ${formatBytes(tf.memory().numBytes)}
      `;
      
      document.getElementById('startIdentification').disabled = false;
    });
  } finally {
    // Clean up batch tensors
    xs.forEach(t => t.dispose());
    ys.forEach(t => t.dispose());
    tf.disposeVariables();
  }

  updateModelInfo();
}

// Identify current user
async function identifyUser() {
  if (!model || points.length < N || !isIdentifying) return;

  // Use tf.tidy for the entire prediction process
  const prediction = await tf.tidy(async () => {
    const features = getFeatures(points);
    const tensorFeatures = tf.tensor2d([features]).toFloat();
    const pred = await model.predict(tensorFeatures, {
      batchSize: 1,
      verbose: 0
    }).array();
    return pred;
  });

  const usernames = Object.keys(usersData);
  
  // Add temperature scaling to soften predictions
  const temperature = 2.0;
  const softPrediction = softmaxWithTemperature(prediction[0], temperature);
  
  // Add new prediction to history
  predictionHistory.push(softPrediction);
  if (predictionHistory.length > PREDICTION_WINDOW) {
    predictionHistory.shift();
  }

  // Calculate average confidence for each user over prediction history
  const avgPredictions = usernames.map((username, idx) => {
    const avgConfidence = predictionHistory.reduce((sum, pred) => sum + pred[idx], 0) / predictionHistory.length;
    return {
      username,
      confidence: avgConfidence * 100,
      currentConfidence: softPrediction[idx] * 100
    };
  }).sort((a, b) => b.confidence - a.confidence);

  // Calculate entropy of current prediction to measure uncertainty
  const entropy = calculateEntropy(softPrediction);
  const certaintyLevel = ((1 - entropy) * 100).toFixed(2);

  // Create HTML for all predictions
  const predictionsHtml = avgPredictions.map(pred => `
    <div class="prediction-details">
      <div class="prediction-header">
        <span>${pred.username}</span>
        <span class="confidence-value">Avg: ${pred.confidence.toFixed(2)}%</span>
        <span class="current-value">Current: ${pred.currentConfidence.toFixed(2)}%</span>
      </div>
      <div class="confidence-container">
        <div class="confidence-bar">
          <div class="confidence-fill" style="width: ${pred.confidence}%"></div>
        </div>
        <div class="confidence-bar current">
          <div class="confidence-fill" style="width: ${pred.currentConfidence}%"></div>
        </div>
      </div>
    </div>
  `).join('');

  document.getElementById('identificationResult').innerHTML = `
    <div class="prediction-result">
      <h4>Most Likely User: ${avgPredictions[0].username}</h4>
      <p>Predictions: ${predictionHistory.length}/${PREDICTION_WINDOW}</p>
      <p>Certainty Level: ${certaintyLevel}%</p>
      <p>Last Update: ${new Date().toLocaleTimeString()}</p>
      <h5>All Predictions:</h5>
      ${predictionsHtml}
    </div>
  `;
}

// Update model information display
function updateModelInfo() {
  const usersList = document.getElementById('usersList');
  const users = Object.keys(usersData);
  
  usersList.innerHTML = `
    <p>Registered Users: ${users.length > 0 ? users.join(', ') : 'None'}</p>
    <p>Total Users: ${users.length}</p>
    <p>Model Status: ${model ? 'Trained' : 'Not Trained'}</p>
    <p>Data points per user:</p>
    <ul>
      ${users.map(user => `<li>${user}: ${usersData[user].length} points</li>`).join('')}
    </ul>
  `;
  
  // Enable train button if we have enough users
  document.getElementById('trainModel').disabled = users.length < 2;
}

// Event Listeners
document.getElementById('startRecording').addEventListener('click', () => {
  const username = document.getElementById('username').value.trim();
  if (!username) {
    alert('Please enter a username');
    return;
  }

  currentMode = 'recording';
  isCollecting = true;
  points = [];
  document.getElementById('startRecording').disabled = true;
  document.getElementById('stopRecording').disabled = false;
  document.getElementById('recordingStatus').innerHTML = `Recording movements for user: ${username}`;
  document.getElementById('recordingStatus').classList.add('recording');
});

document.getElementById('stopRecording').addEventListener('click', () => {
  const username = document.getElementById('username').value.trim();
  isCollecting = false;
  currentMode = null;
  
  if (!usersData[username]) {
    usersData[username] = [];
  }
  usersData[username] = usersData[username].concat(points);
  
  document.getElementById('startRecording').disabled = false;
  document.getElementById('stopRecording').disabled = true;
  document.getElementById('recordingStatus').innerHTML = `Recording stopped. ${points.length} points saved for user: ${username}`;
  document.getElementById('recordingStatus').classList.remove('recording');
  document.getElementById('username').value = '';
  
  updateModelInfo();
});

document.getElementById('trainModel').addEventListener('click', () => {
  try {
    trainModel();
  } catch (error) {
    console.error('Error training model:', error);
    document.getElementById('trainingStatus').innerHTML = `Error: ${error.message}`;
  }
});

document.getElementById('startIdentification').addEventListener('click', () => {
  isIdentifying = true;
  currentMode = 'identification';
  isCollecting = true;
  points = [];
  predictionHistory = [];
  document.getElementById('startIdentification').disabled = true;
  document.getElementById('stopIdentification').disabled = false;
  document.getElementById('identificationStatus').innerHTML = `
    <div class="identification-active">
      <span class="status-indicator status-active"></span>
      Identification Active - Collecting mouse movements...
    </div>
  `;
  document.getElementById('identificationResult').innerHTML = 'Waiting for predictions...';
});

document.getElementById('stopIdentification').addEventListener('click', () => {
  isIdentifying = false;
  isCollecting = false;
  currentMode = null;
  document.getElementById('startIdentification').disabled = false;
  document.getElementById('stopIdentification').disabled = true;
  document.getElementById('identificationStatus').innerHTML = `
    <span class="status-indicator status-inactive"></span>
    Identification Stopped
  `;
});

// Initialize
addEventListener('mousemove', handleMouseMove);
updateModelInfo();

// Add these helper functions
function softmaxWithTemperature(logits, temperature) {
  const scaled = logits.map(l => l / temperature);
  const expScaled = scaled.map(Math.exp);
  const sum = expScaled.reduce((a, b) => a + b, 0);
  return expScaled.map(ex => ex / sum);
}

function calculateEntropy(probs) {
  return -probs.reduce((sum, p) => {
    if (p === 0) return sum;
    return sum + p * Math.log2(p);
  }, 0) / Math.log2(probs.length);
}
</script>
</body>
</html>
